# ==============================================================================
# 题目 1:不使用额外变量交换两个数
# ==============================================================================

def swap_variables_demo():
    print("--- 1. 变量交换演示 ---")
    a = 10
    b = 20  # 修改为不同的值,方便观察交换效果
    print(f"交换前: a = {a}, b = {b}")

    # 🚀【异或运算交换法】
    # 原理基于:
    # 1. n ^ n = 0
    # 2. n ^ 0 = n
    # 3. 交换律和结合律

    a = a ^ b  # 此时 a 保存了 a^b 的信息
    b = a ^ b  # b = (a^b) ^ b = a ^ (b^b) = a ^ 0 = a (b 变成了原来的 a)
    a = a ^ b  # a = (a^b) ^ a = (a^a) ^ b = 0 ^ b = b (a 变成了原来的 b)

    print(f"交换后: a = {a}, b = {b}")

    # 🐍【Python 推荐写法】
    # Python 底层优化了元组解包,既简洁又安全,不会出现异或的坑
    a, b = b, a
    print(f"再换回: a = {a}, b = {b} (使用 Python 原生写法)")
    print("\n")


# ==============================================================================
# 数组元素交换函数
# ==============================================================================
def swap(arr, i, j):
    """
    使用异或运算交换数组中下标为 i 和 j 的两个数
    """
    # 🛑【关键坑点修复】
    # 如果 i 和 j 相等,arr[i] 和 arr[j] 指向内存中同一个位置.
    # 第一步 arr[i] = arr[i] ^ arr[j] 实际上变成了 x = x ^ x,直接导致该位置变为 0.
    # 后续的操作就是在 0 上折腾,最终结果就是该位置的数据丢失(变为0).

    """ 可以把这一段注释看看效果有什么不一样 """
    # if i == j:
    #     return

    # 正常交换逻辑
    arr[i] = arr[i] ^ arr[j]
    arr[j] = arr[i] ^ arr[j]
    arr[i] = arr[i] ^ arr[j]


if __name__ == '__main__':
    # 1. 演示变量交换
    swap_variables_demo()

    # 2. 演示数组交换
    print("--- 2. 数组元素交换演示 ---")
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # ✅ 正常情况：交换索引 0 和 1
    print(f"原始数组: {arr}")
    swap(arr, 0, 1)
    print(f"交换 0,1: {arr}")  # 应该看到 2, 1 开头

    # ⚠️ 危险情况测试:交换索引 0 和 0
    # 如果没有加 if i == j 判断,arr[0] 会变成 0
    swap(arr, 0, 0)
    print(f"交换 0,0: {arr} (如果代码没修bug,第一个数会变成0)")
