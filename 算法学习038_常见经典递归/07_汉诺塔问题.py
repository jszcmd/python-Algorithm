"""
🎯 汉诺塔问题 (Tower of Hanoi)
==================================================
📖 问题描述:
    ┌─────────────────────────────────────────────
    │ 有三根柱子(左、中、右),其中一根柱子上有n个大小不同的圆盘
    │ 从小到大依次叠放.要求将所有圆盘从起始柱子移动到目标柱子
    │ 每次只能移动一个圆盘,且大盘不能放在小盘上面.
    └─────────────────────────────────────────────

🧮 数学规律:
    📊 n层汉诺塔问题的最优步数:2ⁿ - 1
    🔄 递推公式:f(n) = 2 × f(n-1) + 1
    🎯 基础情况:f(1) = 1

⏱️ 复杂度分析:
    ⏰ 时间复杂度：O(2ⁿ)  # 递归树有2ⁿ-1个节点
    💾 空间复杂度：O(n)   # 递归调用栈的最大深度为n
"""


class Solution:
    def move_disks(self, i: int, from_: str, to: str, other: str) -> None:
        """
        🔄 递归移动函数:将i个圆盘从起始柱子移动到目标柱子

        📝 参数说明:
            🎪 i: 要移动的圆盘数量(从1开始编号,1表示最小的圆盘)
            🏁 from_: 起始柱子(圆盘当前所在的柱子)
            🎯 to: 目标柱子(圆盘要移动到的柱子)
            🛠️ other: 辅助柱子(用于中转的柱子)

        🔍 算法思路：
            采用分治策略,将问题分解为三个步骤:
            1. 将上面的i-1个圆盘从起始柱子移动到辅助柱子(递归调用)
            2. 将最大的第i个圆盘从起始柱子移动到目标柱子(直接移动)
            3. 将i-1个圆盘从辅助柱子移动到目标柱子(递归调用)

        💡 核心思想:
            - 通过递归将复杂问题分解为相同结构的子问题
            - 利用辅助柱子作为中转,确保移动过程中始终满足"大盘在下"的约束条件
            - 每次递归调用时,三个柱子的角色会发生变化(起始、目标、辅助)

        🎯 递归终止条件:
            当i == 1时,只有一个圆盘,直接移动到目标柱子
        """
        if i == 1:
            # 🎯 递归基:只有一个圆盘时,直接移动到目标柱子
            print(f"📦 移动圆盘 1 从 {from_} 到 {to}")
        else:
            # 🔄 步骤1:将上面的i-1个圆盘从起始柱子移动到辅助柱子
            # 此时目标柱子变为辅助柱子,辅助柱子变为目标柱子
            self.move_disks(i - 1, from_, other, to)

            # 🎯 步骤2:将最大的第i个圆盘从起始柱子直接移动到目标柱子
            print(f"📦 移动圆盘 {i} 从 {from_} 到 {to}")

            # 🔄 步骤3:将i-1个圆盘从辅助柱子移动到目标柱子
            # 此时起始柱子变为辅助柱子,辅助柱子变为起始柱子
            self.move_disks(i - 1, other, to, from_)

    def hanoi(self, n: int) -> None:
        """
        🎪 汉诺塔问题求解主函数

        📝 参数说明:
            🎪 n: 圆盘的总层数(必须为正整数)

        🎯 功能职责:
            - 参数验证:检查输入的圆盘数量是否合法
            - 启动求解:调用递归函数开始求解过程
            - 结果统计:计算并输出最优移动步数

        ⚠️ 注意事项:
            - 当n较大时(如n>20),递归深度可能超出系统限制
            - 实际移动步骤会随n增大而指数级增长(2ⁿ-1步)
            - 建议测试时n值不要过大,避免输出过多

        🚀 调用示例:
            hanoi(3) 将3个圆盘从左柱子移动到右柱子,使用中柱子作为辅助
        """
        if n <= 0:
            print("❌ 错误:圆盘数量必须大于0")
            return
        elif n > 15:
            print("⚠️  警告:层数较大,移动步骤将非常多,建议减小n值")
            return

        print(f"🎪 {n}层汉诺塔问题求解开始...")
        print("=" * 40)

        # 🚀 启动递归求解:从"左"柱子移动到"中"柱子,使用"右"柱子作为辅助
        self.move_disks(n, "左", "中", "右")

        print("=" * 40)
        print(f"✅ 移动完成!总步数：{2 ** n - 1}(最优解)")
        print(f"💡 数学验证:2^{n} - 1 = {2 ** n - 1}")


if __name__ == '__main__':
    # 🧪 创建解决方案实例并测试
    solution = Solution()

    # 测试3层汉诺塔问题
    print("🧪 测试3层汉诺塔问题")
    print("🔍 移动过程演示:")
    solution.hanoi(3)
