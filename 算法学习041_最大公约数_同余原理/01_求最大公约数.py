""" 最大公约数和最小公倍数 """

"""
gcd(a, b) 求a和b的最大公约数
参数:a - 整数,b - 整数
返回值:a和b的最大公约数
时间复杂度:O(log(a)的三次方)
"""

# 求最大公约数
def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)


"""
🔢 求50和30的最大公约数示例：

🎯 初始调用: gcd(50, 30)
   📝 50 ÷ 30 = 1 余 20
   🔄 递归调用: gcd(30, 20)

🎯 第二次调用: gcd(30, 20)
   📝 30 ÷ 20 = 1 余 10
   🔄 递归调用: gcd(20, 10)

🎯 第三次调用: gcd(20, 10)
   📝 20 ÷ 10 = 2 余 0
   🔄 递归调用: gcd(10, 0)

🎯 第四次调用: gcd(10, 0)
   ⚠️ b = 0,触发终止条件
   ✅ 返回结果: 10

📊 调用链: gcd(50,30) → gcd(30,20) → gcd(20,10) → gcd(10,0) → 返回10
⏱️ 递归深度: 4层
"""


# 最小公倍数
def lcm(a, b):
    return a // gcd(a, b) * b

# 证明辗转相除法就是证明如下关系:
# gcd(a, b) = gcd(b, a % b)
# 假设a % b = r,即需要证明的关系为:gcd(a, b) = gcd(b, r)
# 证明过程:
# 因为a % b = r,所以如下两个等式必然成立
# 1) a = b * q + r,q为0、1、2、3....中的一个整数
# 2) r = a − b * q,q为0、1、2、3....中的一个整数
# 假设u是a和b的公因子,则有: a = s * u, b = t * u
# 把a和b带入2)得到,r = s * u - t * u * q = (s - t * q) * u
# 这说明 : u如果是a和b的公因子,那么u也是r的因子
# 假设v是b和r的公因子,则有: b = x * v, r = y * v
# 把b和r带入1)得到，a = x * v * q + y * v = (x * q + y) * v
# 这说明 : v如果是b和r的公因子,那么v也是a的公因子
# 综上,a和b的每一个公因子 也是 b和r的一个公因子,反之亦然
# 所以,a和b的全体公因子集合 = b和r的全体公因子集合
# 即gcd(a, b) = gcd(b, r)
# 证明结束
