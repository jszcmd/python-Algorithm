from typing import List
from collections import deque

"""
0-1 BFS (åŒç«¯é˜Ÿåˆ—å¹¿åº¦ä¼˜å…ˆæœç´¢) ::: LeetCode 2290
=========================================================================
ğŸš€ ã€ç®—æ³•æ¨¡æ¿ç»ƒä¹ ã€‘åˆ°è¾¾è§’è½éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°ç›®
#### æµ‹è¯•é“¾æ¥: https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/
-------------------------------------------------------------------------
ã€æè¿°ã€‘
ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„äºŒç»´æ•´æ•°æ•°ç»„ grid ï¼Œæ•°ç»„å¤§å°ä¸º m x n ã€‚
æ¯ä¸ªå•å…ƒæ ¼éƒ½æ˜¯ä¸¤ä¸ªå€¼ä¹‹ä¸€ï¼š
- 0 è¡¨ç¤ºä¸€ä¸ª ç©º å•å…ƒæ ¼ï¼Œ
- 1 è¡¨ç¤ºä¸€ä¸ªå¯ä»¥ç§»é™¤çš„ éšœç¢ç‰© ã€‚

ä½ å¯ä»¥å‘ä¸Šã€ä¸‹ã€å·¦ã€å³ç§»åŠ¨ï¼Œä»ä¸€ä¸ªç©ºå•å…ƒæ ¼ç§»åŠ¨åˆ°å¦ä¸€ä¸ªç©ºå•å…ƒæ ¼ã€‚
ç°åœ¨ä½ éœ€è¦ä»å·¦ä¸Šè§’ (0, 0) ç§»åŠ¨åˆ°å³ä¸‹è§’ (m - 1, n - 1) ï¼Œ
è¿”å›éœ€è¦ç§»é™¤çš„éšœç¢ç‰©çš„ æœ€å° æ•°ç›®ã€‚

ã€è¾“å…¥æè¿°ã€‘
grid: äºŒç»´æ•´æ•°æ•°ç»„ï¼Œå¤§å°ä¸º m x n.

ã€è¾“å‡ºæè¿°ã€‘
int: è¿”å›ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°é‡.

ã€ç¤ºä¾‹ 1ã€‘
è¾“å…¥: grid = [[0,1,1],[1,1,0],[1,1,0]]
è¾“å‡º: 2
è§£é‡Š: 
å¯ä»¥ç§»é™¤ä½äº (0, 1) å’Œ (0, 2) çš„éšœç¢ç‰©æ¥åˆ›å»ºä» (0, 0) åˆ° (2, 2) çš„è·¯å¾„ã€‚
è·¯å¾„ä¸º (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2)ã€‚

ã€ç¤ºä¾‹ 2ã€‘
è¾“å…¥: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
è¾“å‡º: 0
è§£é‡Š: ä¸ç§»é™¤ä»»ä½•éšœç¢ç‰©å°±èƒ½ä» (0, 0) åˆ° (2, 4)ã€‚
=========================================================================
"""


class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        move = [-1, 0, 1, 0, -1]  # æ–¹å‘æ•°ç»„æŠ€å·§:é…åˆå¾ªç¯ç”Ÿæˆ ä¸Šã€å³ã€ä¸‹ã€å·¦ å››ä¸ªæ–¹å‘
        m, n = len(grid), len(grid[0])  # è·å–ç½‘æ ¼çš„è¡Œæ•° m å’Œåˆ—æ•° n
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]  # åˆå§‹åŒ–è·ç¦»è¡¨,é»˜è®¤æ— ç©·å¤§
        queue = deque()  # åˆå§‹åŒ–åŒç«¯é˜Ÿåˆ—,ç”¨äº 0-1 BFS
        queue.append((0, 0))  # å°†èµ·ç‚¹ (0,0) åŠ å…¥é˜Ÿåˆ—
        distance[0][0] = 0  # èµ·ç‚¹çš„ç§»é™¤éšœç¢ç‰©ä»£ä»·åˆå§‹åŒ–ä¸º 0
        while queue:  # å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶å¾ªç¯
            x, y = queue.popleft()  # å–å‡ºé˜Ÿå¤´èŠ‚ç‚¹ä½œä¸ºå½“å‰å¤„ç†èŠ‚ç‚¹
            if x == m - 1 and y == n - 1:  # å¦‚æœåˆ°è¾¾å³ä¸‹è§’ç»ˆç‚¹
                return int(distance[x][y])  # ç›´æ¥è¿”å›å½“å‰è®°å½•çš„æœ€å°ä»£ä»·
            for i in range(4):  # éå†å››ä¸ªæ–¹å‘
                nx, ny = x + move[i], y + move[i + 1]  # è®¡ç®—é‚»å±…èŠ‚ç‚¹çš„åæ ‡
                # 0 <= nx < m and 0 <= ny < n  ä¸è¶Šç•Œ
                # distance[x][y]+grid[nx][ny] < distance[nx][ny]  è·ç¦»å˜å°æ‰å»å¤„ç† (æ¾å¼›æ“ä½œ)
                if 0 <= nx < m and 0 <= ny < n and distance[x][y] + grid[nx][ny] < distance[nx][ny]:
                    distance[nx][ny] = distance[x][y] + grid[nx][ny]  # æ›´æ–°åˆ°è¾¾é‚»å±…çš„æœ€çŸ­è·ç¦»
                    if grid[nx][ny] == 0:  # å¦‚æœé‚»å±…æ˜¯ç©ºåœ° (ä»£ä»·0)
                        queue.appendleft((nx, ny))  # æ’é˜Ÿåˆ°é˜Ÿå¤´ (VIPé€šé“,ä¼˜å…ˆå¤„ç†)
                    else:  # å¦‚æœé‚»å±…æ˜¯éšœç¢ç‰© (ä»£ä»·1)
                        queue.append((nx, ny))  # æ’é˜Ÿåˆ°é˜Ÿå°¾ (æ™®é€šé€šé“)
        return -1  # é¢˜ç›®æœ‰è§£,æ˜¯ä¸å¯èƒ½è¿”å›-1çš„
