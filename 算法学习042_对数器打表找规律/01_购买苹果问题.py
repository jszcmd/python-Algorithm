# ==============================================================================
# 🍎 购买苹果问题解决方案集合
# 包含两种解法：
# 1. 🐢 暴力递归 (DFS) - 容易理解但效率低
# 2. 🐇 数学规律 (Math) - 效率极高 O(1)
# ==============================================================================
class Solution:
    # 定义一个表示"无穷大"的常量,代表无法装满的情况
    INF = 2_147_483_647

    # ==========================================================================
    # 🐢 方法一：暴力递归 (Deep First Search)
    # ==========================================================================
    def bags_dfs(self, apple: int) -> int:
        # 🏁 调用递归辅助函数 f
        ans: int = self.f(apple)
        # ⚖️ 如果结果是无效值(INF),说明无法正好装满,返回 -1;否则返回袋子数量
        return ans if ans != self.INF else -1

    def f(self, rest: int) -> int:
        # 🚫 情况1:剩余苹果小于 0,说明这种装法不成立(减多了)
        if rest < 0:
            return self.INF

        # ✅ 情况2:剩余苹果等于 0,说明正好装完,不需要额外的袋子了
        if rest == 0:
            return 0

        # 🌳 分支1:尝试使用 8 规格的袋子 🎒
        # 递归计算:如果用了1个8号袋,剩下的苹果还需要几个袋子?
        p1: int = self.f(rest - 8)

        # 🌳 分支2:尝试使用 6 规格的袋子 🎒
        # 递归计算:如果用了1个6号袋,剩下的苹果还需要几个袋子?
        p2: int = self.f(rest - 6)

        # 📝 结果处理:
        # 如果 p1 是有效解 (不是 INF),那么总袋数 = 剩下的袋数 + 当前这 1 个袋子
        # 否则保持为 INF (无效状态)
        p1 += 1 if p1 != self.INF else 0

        # 同理处理 p2
        p2 += 1 if p2 != self.INF else 0

        # ⚖️ 抉择:返回两种方案中袋子更少的那一个 (min)
        return min(p1, p2)

    # ==========================================================================
    # 🐇 方法二：数学规律 / 找规律 (Pattern Matching)
    # 基于暴力求解的结果观察得出的 O(1) 公式
    # ==========================================================================
    def bags_math(self, apple: int) -> int:
        # 🚫 奇数检查:6和8都是偶数,不可能凑出奇数个苹果
        # (apple & 1) != 0 等价于 apple % 2 != 0
        if (apple & 1) != 0:
            return -1

        # 📉 小数特判区间 (小于18的情况)
        # 为什么是18?因为18 (6+6+6) 是纯用6号袋的一个分界点，
        # 大于18的偶数通常都能通过调整6和8的组合找到解
        elif apple < 18:
            if apple == 0:
                return 0  # 0个苹果0个袋
            elif apple == 6 or apple == 8:
                return 1  # 恰好1袋
            elif apple == 12 or apple == 14 or apple == 16:
                return 2  # 恰好2袋 (6+6, 6+8, 8+8)
            else:
                return -1  # 例如 2, 4, 10 这种无法凑出的偶数

        # 🚀 大数公式区间 (大于等于18的偶数)
        # 规律:每增加 8 个苹果,袋子数加 1.
        # 基础偏移量是通过观察 (apple - 18) 得到的
        else:
            return (apple - 18) // 8 + 3


# ==============================================================================
# ▶️ 主程序测试入口
# ==============================================================================
if __name__ == '__main__':
    s = Solution()
    print("--------------------------------------------------")
    print("📊 对比测试 (前 40 个数字)")
    print("--------------------------------------------------")

    for i in range(1, 41):
        # 🐢 运行暴力解法
        res_dfs = s.bags_dfs(i)
        # 🐇 运行数学解法
        res_math = s.bags_math(i)

        # 只有当有解的时候才打印,或者打印特定的几个数
        status = "✅" if res_math != -1 else "❌"

        # 打印格式：数字 -> 结果 (验证两个方法结果是否一致)
        # 只有当结果不一致时报错 (理论上不会发生)
        check = "一致" if res_dfs == res_math else "⚠️不一致"

        print(f"🍎 {i:02d} 个苹果 | 袋子数: {res_math} | {status} | {check}")

    print("\n💡 提示：方法二(Math) 直接计算,速度远快于 方法一(DFS)")
