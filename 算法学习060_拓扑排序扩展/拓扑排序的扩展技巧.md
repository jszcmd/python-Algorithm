# 算法讲解060【必备】拓扑排序的扩展技巧

**讲师**：左程云

## 前置知识
1. **讲解041-同余原理**
2. **讲解059~讲解065**：都是【必备】课程有关图的内容，建议从头开始学习。

---

## 本节课内容

本节课继续讲解拓扑排序的题目。

### 重要技巧
**利用拓扑排序的过程，上游节点逐渐推送消息给下游节点的技巧。**

> **注意**：
> 这个技巧已经是树型 DP（动态规划）的内容了，不过即便不会动态规划，本节课也能听懂。
> 动态规划专题（包括树型 DP）会在后续【必备】课程里讲述。

---

## 题目1：最大食物链计数

### 题目描述
* `a -> b`，代表 `a` 在食物链中被 `b` 捕食。
* 给定一个有向无环图，返回这个图中从最初级动物到最顶级捕食者的食物链有几条。

### 注意事项
本题答案很大，需要取模。不了解的同学请参考“讲解041-同余原理”。

### 测试链接
[Luogu P4017](https://www.luogu.com.cn/problem/P4017)

``````python
# ======================================================================================
# 题目: P4017 最大食物链计数
# 来源: 洛谷 (Luogu)
# #### 测试连接: https://www.luogu.com.cn/problem/P4017
#
# 题目描述:
# 给你一个食物网，你要求出这个食物网中最大食物链的数量。
# (这里的"最大食物链", 指的是生物学意义上的食物链, 即最左端是不会捕食其他生物的生产者,
# 最右端是不会被其他生物捕食的消费者.)
#
# 由于这个结果可能过大, 你只需要输出总数模上 80112002 的结果.
#
# 输入格式:
# 第一行, 两个正整数 n、m, 表示生物种类 n 和吃与被吃的关系数 m.
# 接下来 m 行，每行两个正整数 A B, 表示被吃的生物 A 和吃 A 的生物 B (即存在边 A -> B)。
#
# 输出格式:
# 一行一个整数, 为最大食物链数量模上 80112002 的结果.
#
# 数据范围:
# 1 <= n <= 5000
# 1 <= m <= 500000
# 保证图中不会出现环(DAG).
# ======================================================================================

import sys
from collections import deque


def ways():
    MOD: int = 80112002
    # 一次性读入所有的数据,并以空格分割,input_data此时是一个列表
    input_data = sys.stdin.read().split()
    if not input_data: return 0  # 没有输入任何数据,直接返回
    # 把读入的数据转成可迭代对象,方便获取数据
    iterator = iter(input_data)

    try:
        n = int(next(iterator))  # 读入节点数n
        m = int(next(iterator))  # 读入边的数量m
    except StopIteration:
        return 0  # 当要读入的迭代器没有数据,直接退出

    # 邻接表建图 : adjList[u] : 表示节点u指向的所有节点
    adjList = [[] for _ in range(n + 1)]  # 0位置不用
    # 入度表: indegree[i] 表示有多少条边指向节点i
    indegree = [0] * (n + 1)  # 0位置也不用
    # 向上推送的信息,默认初始化为0
    lines = [0] * (n + 1)  # 0位置也不使用
    # 拓扑排序需要的队列
    queue = deque()

    # 建图,添加这m条边
    for _ in range(m):
        u = int(next(iterator))  # 起点
        v = int(next(iterator))  # 终点
        adjList[u].append(v)  # u-->v建一条边
        indegree[v] += 1  # 节点v的入度++

    # 先把入度为0的节点加入到队列
    for i in range(1, n + 1):  # 从节点1开始
        if indegree[i] == 0:
            queue.append(i)  # 把入度为0的点加入到队列里面
            lines[i] = 1  # 最开始入度为0的消息设置为1

    ans: int = 0  # 要返回的答案

    # 开始拓扑排序
    while queue:
        cur = queue.popleft()  # 弹出最左边的元素(入度为0的节点)

        if len(adjList[cur]) == 0:  # 当前弹出的节点不在有任何邻居了
            ans = (ans + lines[cur]) % MOD
        else:  # 当前弹出的节点还有邻居
            for v in adjList[cur]:  # 遍历cur的所有邻居v
                lines[v] = (lines[cur] + lines[v]) % MOD  # 把u的路径加入到v上面去
                indegree[v] -= 1  # v的入度--
                if indegree[v] == 0: queue.append(v)  # 把入度为0的邻居加入到队列里面

    return ans


if __name__ == '__main__':
    print(ways())
``````



---

## 题目2：喧闹和富有 (Loud and Rich)

### 题目描述
* 有一组人，从 `0` 到 `n - 1` 编号，其中每个人都有不同数目的钱，以及不同程度的安静值。
* 给你一个数组 `richer`，其中 `richer[i] = [ai, bi]` 表示 person `ai` 比 person `bi` 更有钱。
* 还有一个整数数组 `quiet`，其中 `quiet[i]` 是 person `i` 的安静值。
* `richer` 中所给出的数据逻辑自洽（即：在 `x` 比 `y` 更有钱的同时，不会出现 `y` 比 `x` 更有钱的情况）。

**目标**：
返回一个整数数组 `answer` 作为答案，其中 `answer[x] = y` 的前提是：
在所有拥有的钱 **肯定不少于** person `x` 的人中，person `y` 是 **最安静** 的人（也就是安静值 `quiet[y]` 最小的人）。

### 测试链接
[LeetCode 851](https://leetcode.cn/problems/loud-and-rich/)

``````python
# ======================================================================================
# 题目: 851. 喧闹和富有 (Loud and Rich)
# 来源: LeetCode
# #### 测试链接: https://leetcode.cn/problems/loud-and-rich/description/
#
# 题目描述:
# 有一组 n 个人作为实验对象, 从 0 到 n - 1 编号, 其中每个人都有不同数目的钱,
# 以及不同程度的安静值 (quietness).
#
# 给你一个数组 richer，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱.
# 另给你一个整数数组 quiet, 其中 quiet[i] 是 person i 的安静值.
# richer 中所给出的数据 逻辑自洽 (也就是说, 在 person x 比 person y 更有钱的同时,
# 不会出现 person y 比 person x 更有钱的情况 ).
#
# 现在, 返回一个整数数组 answer 作为答案, 其中 answer[x] = y 的前提是:
# 在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人(也就是安静值 quiet[y] 最小的人).
#
# 示例 1:
# 输入: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
# 输出: [5,5,2,5,4,5,6,7]
#
# 提示:
# n == quiet.length
# 1 <= n <= 500
# 0 <= quiet[i] < n
# quiet 的所有值 互不相同
# 0 <= richer.length <= n * (n - 1) / 2
# ======================================================================================

from collections import deque
from typing import List


class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        n = len(quiet)  # 安静数组的长度,也是节点的个数
        # 邻接表建图 : adjList[u] : 表示节点u指向的所有节点
        adjList = [[] for _ in range(n)]  # 0位置的也使用
        # 入度表: indegree[i] 表示有多少条边指向节点i
        indegree = [0] * n  #
        # 拓扑排序需要的队列
        queue = deque()
        # 安静数组(要返回的), ans[x]:比x有钱且比x安静的
        ans = [x for x in range(n)]  # 最开始每个人最安静的人默认是自己

        # 添加边,建图
        for u, v in richer:
            adjList[u].append(v)  # u-->v 添加一条边
            indegree[v] += 1  # 节点v的入度++

        # 把入度为0的加入到队列里面
        for i in range(n):
            if indegree[i] == 0: queue.append(i)  # 发现入度为0的节点加入到队列

        while queue:
            cur = queue.popleft()  # 弹出入度为0的节点
            for v in adjList[cur]:  # 遍历cur的邻居v,cur是比v都更加富有的
                # 发现cur已经知道的且比cur安静的 比 v已知的且比v安静的还要安静
                if quiet[ans[cur]] < quiet[ans[v]]: ans[v] = ans[cur]  # 更行v的安静数组
                indegree[v] -= 1  # cur的邻居的入度--
                if indegree[v] == 0: queue.append(v)  # 发现入度为0的点加入到队列

        return ans
``````



---

## 题目3：并行课程 III (Parallel Courses III)

### 题目描述
* 给你一个整数 `n`，表示有 `n` 节课，课程编号从 `1` 到 `n`。
* 同时给你一个二维整数数组 `relations`，其中 `relations[j] = [prevCourse_j, nextCourse_j]` 表示课程 `prevCourse_j` 必须在课程 `nextCourse_j` 之前完成（先修课的关系）。
* 同时给你一个下标从 `0` 开始的整数数组 `time`，其中 `time[i]` 表示完成第 `(i+1)` 门课程需要花费的月份数。

**规则**：
1. 如果一门课的所有先修课都已经完成，你可以在 **任意** 时间开始这门课程。
2. 你可以 **同时** 上任意门课程。

**目标**：
请你返回完成所有课程所需要的 **最少** 月份数。
*(注意：测试数据保证一定可以完成所有课程，也就是先修课的关系构成一个有向无环图)*

### 测试链接
[LeetCode 2050](https://leetcode.cn/problems/parallel-courses-iii/)

``````python
"""
======================================================================================
题目: 2050. 并行课程 III (Parallel Courses III)
难度: 困难 (Hard)
来源: LeetCode
#### 测试链接: https://leetcode.cn/problems/parallel-courses-iii/

描述:
给你一个整数 n , 表示有 n 节课, 课程编号从 1 到 n .
同时给你一个二维整数数组 relations , 其中 relations[j] = [prevCourse_j, nextCourse_j] ,
表示课程 prevCourse_j 必须在课程 nextCourse_j 之前 完成(先修课的关系).
同时给你一个下标从 0 开始的整数数组 time , 其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数.

请你根据以下规则算出完成所有课程所需要的 最少 月份数:
1. 如果一门课的所有先修课都已经完成, 你可以在 任意 时间开始这门课程.
2. 你可以 同时 上 任意门课程 .

请你返回完成所有课程所需要的 最少 月份数.

注意: 测试数据保证一定可以完成所有课程(也就是先修课的关系构成一个有向无环图).
======================================================================================
"""

from typing import List


class Solution:
    MAX = 50001  # 最大的节点数,同时也是最大的边的数量
    # 链式前向星建图所需要的变量
    head: list[int] = [0] * MAX
    next: list[int] = [0] * MAX
    to: list[int] = [0] * MAX
    cnt: int = 0

    # 拓扑排序需要的队列
    queue: list[int] = [0] * MAX
    l: int = 0  # 队列头部的指针
    r: int = 0  # 队列尾部的指针

    # 入度表 下标 1-n
    indegree: list[int] = [0] * MAX  # 0位置弃而不用

    # 花费表 cost[i]: 表示完成课程i,以及其前面的课程所需要的时间
    cost: list[int] = [0] * MAX

    # 初始化函数
    def build(self) -> None:
        self.l = self.r = 0  # 初始化队列
        self.cnt = 1  # 边的编号从1开始,这样0就可以表示"没有边"
        self.head = [0] * self.MAX  # 初始化头指针数组
        self.indegree = [0] * self.MAX  # 清空入度表
        self.cost = [0] * self.MAX  # 清空花费表

    # 建图,添加边的函数
    def addChainEdge(self, u: int, v: int) -> None:
        self.next[self.cnt] = self.head[u]  # 新边的next指向旧的头部head[u]
        self.to[self.cnt] = v  # 第cnt条边的终点是v
        self.head[u] = self.cnt  # 更新节点u的新边,为:第cnt条边
        self.cnt += 1  # cnt++,为下一条边做准备

    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        # n:节点的个数  节点的关系[1,2,3,...,n]节点是从1开始的, 一共有 1,2,...,n这么多个节点
        # 时间time:  0下标: time[0] 代表1这件事完成的时间 依次类推
        # 也就是说, 时间i完成单个事件i,所需要的时间是: time[i-1]

        self.build()  # 初始化
        # 建立图,添加边
        for u, v in relations:
            self.addChainEdge(u, v)  # u-->v 添加一条边
            self.indegree[v] += 1  # 节点v的入度++

        # 先遍历一遍,把入度为0的节点加入到队列里面
        for i in range(1, n + 1):
            if self.indegree[i] == 0:
                self.queue[self.r] = i  # 加入到r位置
                self.r += 1  # r++,队列的长度+1
        # 开始拓扑排序
        while self.l < self.r:
            cur: int = self.queue[self.l]  # 弹出入度为0的节点
            self.l += 1  # 队列头部指针++
            # cost[cur]在此之前表示,完成cur之前的课程所需要的时间 time[cur-1]:cur这个课程单点完成所需要的时间
            self.cost[cur] += time[cur - 1]  # 每一个点完成的时间先加自己的单点,更新成完成这课程以及前面的课程所需要的时间
            # 遍历cur的邻居,也就是后续的课程,给后续的课程推时间
            ei = self.head[cur]  # cur的第一条边的编号
            while ei > 0:
                v = self.to[ei]  # cur的邻居节点v
                # 这个时候 cost[v]可能已经有一个完成v之前的课程所需要的时间,现在跟我的这个 cur推的时间比
                self.cost[v] = max(self.cost[v], self.cost[cur])  # 谁更大就维持谁
                self.indegree[v] -= 1  # 邻居v的入度--
                if self.indegree[v] == 0:
                    self.queue[self.r] = v  # 把入度为0的节点加入到队列里面
                    self.r += 1  # 队列的队尾指针++,队列的长度+1
                ei = self.next[ei]  # 去下一条边

        ans: int = max(self.cost)

        return ans

``````



---

## 题目4：参加会议的最多员工数 (Maximum Employees to Be Invited to a Meeting)

### 题目描述
* 一个公司准备组织一场会议，邀请名单上有 `n` 位员工。
* 公司准备了一张 **圆形** 的桌子，可以坐下 **任意数目** 的员工。
* 员工编号为 `0` 到 `n - 1`。每位员工都有一位 **喜欢** 的员工。
* 每位员工 **当且仅当** 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 **不会** 是他自己。
* 给你一个下标从 `0` 开始的整数数组 `favorite`，其中 `favorite[i]` 表示第 `i` 位员工喜欢的员工。

**目标**：
请你返回参加会议的 **最多员工数目**。

### 测试链接
[LeetCode 2127](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/)

``````python
"""
======================================================================================
题目: 2127. 参加会议的最多员工数 (Maximum Employees to Be Invited to a Meeting)
测试链接: https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/
难度: 困难 (Hard)
来源: LeetCode

描述:
一个公司准备组织一场会议, 邀请名单上有 n 位员工。
公司准备了一张 圆形 的桌子, 可以坐下 任意数目 的员工。

员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工, 每位员工 当且仅当 他被安排在喜欢员工的旁边,
他才会参加会议。每位员工喜欢的员工 不会 是他自己。

给你一个下标从 0 开始的整数数组 favorite , 其中 favorite[i] 表示第 i 位员工喜欢的员工。
请你返回参加会议的 最多员工数目。
======================================================================================
"""

from typing import List
from collections import deque


class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        # favorite数组本身就可以表示图: favorite[a]=b : a --> b
        n = len(favorite)  # 人数
        # 入度表
        indegree = [0] * n  # 入度表,0位置也使用
        # 拓扑排序需要的队列
        queue = deque()  # 使用collections库中的队列
        # 深度链数组
        deep = [0] * n  # deep[i]不包括i在内,i之前的最长链的长度

        # 先统计入度表
        for i in range(n):
            indegree[favorite[i]] += 1
        # 先把入度为0的点加入到队列里面
        for i in range(n):
            if indegree[i] == 0: queue.append(i)  # 把入度为0的点加入到队列里面

        # 拓扑排序的主要逻辑
        while queue:
            cur = queue.popleft()  # 弹出入度为0的节点
            next = favorite[cur]  # cur喜欢的人(cur的邻居)
            indegree[next] -= 1  # next节点的入度-1
            deep[next] = max(deep[next], deep[cur] + 1)  # 维持最长链的长度
            if indegree[next] == 0: queue.append(next)  # 把入度为0的邻居加入到队列里面
        """ 拓扑排序结束以后,目前,不在环上的点,都删除了!!! 不在环上面的节点i : indegree[i] = 0. """

        # 可能性1: 所有小环(中心个数 == 2), 算上中心点 + 延伸点 总个数
        sumOfSmallRings = 0
        # // 可能性2: 所有大环(中心个数 > 2), 只算中心点, 最大环中心点个数
        bigRings = 0
        # 再遍历一遍所有节点,只关心环
        for i in range(n):
            if indegree[i] > 0:
                ringSize = 1
                indegree[i] = 0
                j = favorite[i]
                while j != i:  # 只要是j不等于i,就一直绕圈
                    ringSize += 1
                    indegree[j] = 0  # 沿途把入度改成0,一个环只绕一次
                    j = favorite[j]  # 一直绕圈
                if ringSize == 2:  # 遇到小环
                    sumOfSmallRings += 2 + deep[i] + deep[favorite[i]]  # 小环累加
                else:  # 遇到大环
                    bigRings = max(bigRings, ringSize)  # 大环取最大值

        return max(sumOfSmallRings, bigRings)

``````

