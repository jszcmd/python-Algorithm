"""
=============================================================
题目名称：地毯 (加深版)
#### 测试链接: https://www.luogu.com.cn/problem/P3397

【题目描述】
在一个 n * n 的正方形格子上,总共铺设了 m 块地毯.
每一块地毯的信息都会给出:
- 左上角坐标 (x1, y1)
- 右下角坐标 (x2, y2)

现在的任务是:
计算并输出每一个格子 (i, j) 到底被多少块地毯覆盖了.

-------------------------------------------------------------
【输入格式】
1. 第一行输入两个正整数 n 和 m.
- n: 格子的大小 (n * n)
- m: 地毯的数量

2. 接下来 m 行，每行输入 4 个整数: x1 y1 x2 y2
- 代表一块地毯覆盖的矩形区域.
- 左上角是 (x1, y1),右下角是 (x2, y2).

-------------------------------------------------------------
【输出格式】
输出 n 行,每行有 n 个整数.
第 i 行第 j 列的数字,代表坐标 (i, j) 这个点被覆盖的层数.
(数字之间用空格隔开)
-------------------------------------------------------------
=============================================================
"""

import sys

# 【配置】最大矩阵尺寸
# 预留边界(padding)防止下标越界,对应 C 语言的 MAX
MAX = 1005

# 初始化二维数组,全0
# 使用列表推导式创建独立的行对象
arr = [[0]*(MAX) for _ in range(MAX)]

# 【变量定义】
n:int = 0 # 矩阵大小 n*n
m:int = 0 # 操作次数 m

# 【核心算法 1】二维差分更新
# 作用:在 O(1) 时间内标记矩形区域 (a,b) 到 (c,d) 的数值增加 v
def add(a:int, b:int, c:int, d:int, v:int):
    arr[a][b] += v             # 左上角:增加数值
    arr[c+1][b] -= v           # 右上角的右侧(下一行同列):消除横向影响
    arr[a][d+1] -= v           # 左下角的下方(同行下列):消除纵向影响
    arr[c+1][d+1] += v         # 右下角的右下方:补回因重复减去而被抵消的数值

# 【核心算法 2】二维前缀和构建
# 作用:将差分标记还原为最终的覆盖数值
# 时间复杂度:O(n^2)
def build():
    # 只需要计算有效区域 1 到 n
    for i in range(1, n+1):
        for j in range(1, n+1):
            # 递推公式:当前位置 = 左 + 上 - 左上 + 差分标记
            arr[i][j] += arr[i][j-1] + arr[i-1][j] - arr[i-1][j-1]

if __name__ == '__main__':
    # 【性能优化】快速 I/O 读取
    # 一次性读取所有输入流,避免频繁 I/O 导致超时
    input_data = sys.stdin.read().split()
    
    # 判空处理
    if not input_data:
        sys.exit(0)

    # 创建迭代器,用于顺序解析整数
    iterator = iter(input_data)
    
    try:
        # 1. 读取基础参数:n(矩阵大小), m(操作次数)
        n = int(next(iterator))
        m = int(next(iterator))

        # 2. 循环处理 m 次差分操作
        for _ in range(m):
            a = int(next(iterator))
            b = int(next(iterator))
            c = int(next(iterator))
            d = int(next(iterator))
            # 执行差分标记,地毯覆盖权值为 1
            add(a, b, c, d, 1)

    except StopIteration:
        pass
    
    # 3. 执行前缀和计算,还原最终结果
    build()
    
    # 4. 输出结果
    # 遍历有效行 (1 到 n)
    for i in range(1, n+1):
        # 使用切片 arr[i][1:n+1] 获取有效列数据
        # 使用 * 解包操作符,按空格分隔打印
        print(*arr[i][1:n+1])